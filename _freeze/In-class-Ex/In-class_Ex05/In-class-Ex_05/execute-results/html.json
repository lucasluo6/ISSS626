{
  "hash": "b62c70f809e0b91000ba7c8e67dca7fa",
  "result": {
    "markdown": "---\ntitle: \"In class exercise 05\"\nauthor: \"Luo Yuming\"\ndate: \"septerber 23, 2024\"\ndate-modified: \"Last-modified\"\nexecute:\n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n#5.4.1 Deriving Queens Contiguity Weights: sfdep methods\nnb: A neighbor list object as created by st_neighbor.\nstyle: Default 'W' for row standardized weights. This value can also be 'B', 'C', 'U', 'minimax', and 'S'\nallow_zero: if TRUE, assigns zero as a lagged value to zone without neighbors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `/Users/lucasluo/Desktop/SMU/Courses/Term3 Aug-Dec/ISSS626-Geospatial Analytics and Applications/lucasluo6/ISSS626/In-class-Ex/In-class_Ex05/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\nhunan_GDPPC <- left_join(hunan, hunan2012) %>%\n  select(1:4, 7, 15)                             \n\nwm_q=hunan_GDPPC%>%\n  mutate(nb=st_contiguity(geometry),\n         wt=st_weights(nb,\n                       style='W'),\n         .before=1)\n```\n:::\n\n#5.4.2 Computing Global Moran's I\n\nWe use the global_moran() function to compute this.\nThe below code chunk, using global_moran_test() helps us conduct the test easier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI= global_moran(wm_q$GDPPC,\n                     wm_q$nb,\n                     wm_q$wt)\n\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\nSince p-value is less than 0.05, we infer that there is indeed a sign of positive autocorrelation.\n\n\n#5.4.3 Global Moran's Permutation Test\n\nIn practice, we generally use Monte Carlo simulation to conduct tests. This is where the global_moran_perm() function comes into play. The nsim argument is key.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n:::\n\n#5.4.4 Computing Local Moran's I\n\nIn this section, we use the local_moran() function of the sfdep package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa=wm_q%>%\n  mutate(local_moran=local_moran(\n    GDPPC, nb, wt, nsim=99),\n    .before=1)%>%\n  unnest(local_moran)\n```\n:::\n\nunnest() helps us combine the data into the intended data-frame.\n\n#5.4.5 Visualizing p-value of local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](In-class-Ex_05_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n##5.4.5.1 Visualizing Local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](In-class-Ex_05_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n##5.4.5.2 Visualizing both\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap1= tm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n\nmap2= tm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n\ntmap_arrange(map1,map2, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-class-Ex_05_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n#5.4.6 Visualizing LISA map\n\nLISA map is a categorical map showing outliers and clusters. There are two types of outliers- high-low and low-high outliers. Likewise, there are two types of clusters namely High-High and Low-Low.\n\nIn fact, LISA map is an interpreted map by combining local Moran's I of geographical areas and their respective p values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig=lisa%>%\n  filter(p_ii<0.05)\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_polygons()+\n  tm_borders(alpha=0.5)+\n  tm_shape(lisa_sig)+\n  tm_fill('mean')+\n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output-display}\n![](In-class-Ex_05_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\nWe see two outliers in the cluster on the North-East region of Hunan which contains mostly high-high regions. rm -f .git/index.lock\n\n#5.5 Computing Local Gi statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw=hunan_GDPPC%>%\n  mutate(nb=st_contiguity(geometry),\n         wts=st_inverse_distance(nb, geometry, scale=1, alpha=1),\n         .before=1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA=wm_idw%>%\n  mutate(local_Gi=local_gstar_perm(\n    GDPPC, nb, wt, nsim=99),\n    .before=1)%>%\n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000692  0.0165 9.87e-1  0.84         0.42    0.715\n 2 -0.333  Low     0.0104 0.00000464  0.0123 9.90e-1  0.84         0.42    1.11 \n 3  0.281  High    0.0125 0.00000619 -0.127  8.99e-1  0.98         0.49    0.615\n 4  0.411  High    0.0109 0.00000624  0.669  5.03e-1  0.48         0.24    0.782\n 5  0.387  High    0.0116 0.00000896  0.327  7.44e-1  0.66         0.33    0.994\n 6 -0.368  High    0.0116 0.00000650 -0.506  6.13e-1  0.82         0.41    0.944\n 7  3.56   High    0.0146 0.00000614  3.07   2.13e-3  0.04         0.02    0.927\n 8  2.52   High    0.0135 0.00000466  1.77   7.72e-2  0.1          0.05    0.764\n 9  4.56   High    0.0141 0.00000621  3.53   4.08e-4  0.04         0.02    1.27 \n10  1.16   Low     0.0106 0.00000632  1.31   1.92e-1  0.28         0.14    1.39 \n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(HCSA)+\n  tm_fill('p_sim')+\n  tm_borders(alpha=0.5)\n```\n\n::: {.cell-output-display}\n![](In-class-Ex_05_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\nWe can now visualize the hot and cold spots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig=HCSA%>%\n  filter(p_sim<0.05)\ntm_shape(HCSA)+\n  tm_polygons()+\n  tm_borders(alpha = 0.5)+\n  tm_shape(HCSA_sig)+\n  tm_fill('cluster')\n  tm_borders(alpha=0.4)\n```\n:::",
    "supporting": [
      "In-class-Ex_05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}